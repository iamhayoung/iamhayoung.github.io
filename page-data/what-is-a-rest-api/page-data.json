{
    "componentChunkName": "component---src-templates-blog-post-js",
    "path": "/what-is-a-rest-api/",
    "result": {"data":{"site":{"siteMetadata":{"title":"✏️ hayoung.life"}},"markdownRemark":{"id":"ac045ddb-22a4-59c5-a33f-faed877d4795","excerpt":"REST는 HTTP의 주요 저자인 Roy Fielding의 2000년 박사 학위 논문에서 소개된 네트워크 아키텍처 설계 지침이다. “REST”라는 단어를 떠올리면 바로 REST API가 떠오르는데, 사실 REST는 “API…","html":"<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/591ebfd2771753cb56220800e4e7797a/df305/thumbnail.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 44.93670886075949%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAYAAAAywQxIAAAACXBIWXMAAAsTAAALEwEAmpwYAAABHElEQVQoz4VSTU/CQBDlV+Bf6o/wZPw5XjioiReuxZMXYmJDomcxKh8BiV6It3a7UrdIu20fmYFtNluIm7xMZ2fmzevMtkoUKCoNY20cirl5dg6h5RblRYZMb6DLnO8qlPxN9r+mNaF9aR+5ihEMAowm7xi+PGP2MdtHqtraZA2FpMzv+bi6vsR8MeeCUIRIVAIhIyRqxTTDt1fc9ftYfH2yry21NSEVq7WC53lot0/Qu/X3KiViKRCJkON0brpdnJ6d4z54YJ/GdFAhYfm9xHg6wXqT8tyITMQRhBT4TRMmGDw94qLTwWg63iks86ZCY9M/Bfkj6q6Z3i2JfLMo+nUC5bovoEFIRVTsDtuGyTENjm7ZJXGfyLEc224BoIyyeLJrWLMAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"REST API\"\n        title=\"REST API\"\n        src=\"/static/591ebfd2771753cb56220800e4e7797a/984b6/thumbnail.png\"\n        srcset=\"/static/591ebfd2771753cb56220800e4e7797a/4d6f2/thumbnail.png 158w,\n/static/591ebfd2771753cb56220800e4e7797a/3c1ae/thumbnail.png 315w,\n/static/591ebfd2771753cb56220800e4e7797a/984b6/thumbnail.png 630w,\n/static/591ebfd2771753cb56220800e4e7797a/e7d8e/thumbnail.png 945w,\n/static/591ebfd2771753cb56220800e4e7797a/58c38/thumbnail.png 1260w,\n/static/591ebfd2771753cb56220800e4e7797a/df305/thumbnail.png 2363w\"\n        sizes=\"(max-width: 630px) 100vw, 630px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p>REST는 HTTP의 주요 저자인 <a href=\"https://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm\">Roy Fielding의 2000년 박사 학위 논문</a>에서 소개된 네트워크 아키텍처 설계 지침이다.</p>\n<p>“REST”라는 단어를 떠올리면 바로 REST API가 떠오르는데, 사실 REST는 “API”만을 설계하기 위한 지침이 아니다. 첫 문장에서 소개했듯, 네트워크에서 통신을 구성하기 위한 설계 지침이다. 훨씬 넓은 대상 범위를 가진 가이드라인이다.</p>\n<p>REST라는 개념이 REST API로 보편화된 이유는, <strong>현 시대의 네트워크에서 HTTP 기반의 통신이 큰 비중을 차지하기 때문</strong>인 것 같다. HTTP 기반의 통신 환경에서 API를 개발하는 것에 있어서 REST를 준수함으로써 얻게 되는 이점이 많기 때문인 듯 하다.</p>\n<p>그만큼 HTTP 기반의 통신 환경에서 사용되는 API의 대다수는 REST 아키텍처의 원칙을 지향 (준수)하고 있다.</p>\n<blockquote>\n<p>✅ 따라서, 이 글에서는 흔히 HTTP 기반의 API 개발에서 통용되는 REST에 대해 정리해볼 생각이다. <strong>REST의 원론적인 개념에 대해 깊은 이해가 필요하다면, REST를 제안한 <a href=\"https://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm\">Roy Fielding의 2000년 박사 학위 논문</a>를 참고</strong>하는 것을 추천한다.</p>\n</blockquote>\n<p><strong>REST API</strong>는 <strong>REST 원칙을 준수하여 개발한 API</strong>를 말한다. REST의 원칙을 성실히 지킨 아키텍처를 “RESTful하다” 라고 표현한다.</p>\n<h1>REST?</h1>\n<p>REST는 「<strong>RE</strong>presentational <strong>S</strong>tate <strong>T</strong>ransfer」의 약자이다.</p>\n<blockquote>\n<ul>\n<li><strong>Representational</strong> : 구상적인</li>\n<li><strong>State</strong>: 상태의</li>\n<li><strong>Transfer</strong>: 전송 (환승)</li>\n</ul>\n</blockquote>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/cc0b40a2f40da449fd9e6c946133435d/ad973/representational.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 42.405063291139236%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAYAAAD5nd/tAAAACXBIWXMAAAsTAAALEwEAmpwYAAABRElEQVQoz52RwXKcMBBE+VN/Vj4jN39DbvExWzbLbkI2sICQkEBIAj2XZGMfckmlq7q6NaOaGrWKvu85nX7QNB0mBu5q4HR+xu4ez4aLAUd41w0bPSuBR/nEQ/mFNihqLzhQzGam/dMipURbw295p2prunmkM++cR/pFZt/qgUYPfB9Kvt6+0Zsx0y4Ly7JQaGdoTc+kJpRSNE2Ttes6xDgihCC94na7IUbBYhfmeSZYBy6yLpa7FvRKYLSmmHeLCIrNB3zwGGPw3mOtzZq4rita6+wPRCJ73LNfd0/Yt7cnp1W7puVfEWP8i8TPXuFC5HJ3dINkUurtwn/gGF445/nZSKrrL15enjmfz1wuF+q6pizLrAerqsq1Q6/Xa842RfKx4RYCUipGKXN+KatpmnLwySem30vn1E+9o56Y6tu2fQx8BcUoZ6YPViKaAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Representational의 한국어\"\n        title=\"Representational의 한국어\"\n        src=\"/static/cc0b40a2f40da449fd9e6c946133435d/984b6/representational.png\"\n        srcset=\"/static/cc0b40a2f40da449fd9e6c946133435d/4d6f2/representational.png 158w,\n/static/cc0b40a2f40da449fd9e6c946133435d/3c1ae/representational.png 315w,\n/static/cc0b40a2f40da449fd9e6c946133435d/984b6/representational.png 630w,\n/static/cc0b40a2f40da449fd9e6c946133435d/ad973/representational.png 722w\"\n        sizes=\"(max-width: 630px) 100vw, 630px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p>“구상적”이라는 단어는 한국어로도 어렵다.</p>\n<p>나는 <a href=\"https://ko.dict.naver.com/#/search?query=%EA%B5%AC%EC%83%81%EC%A0%81\">네이버 국어사전</a>에 정의된 뜻을 통해, “구상적”을 “무언가를 <strong>인지하고 이해할 수 있도록 형태와 성질을 갖추고 있는 것</strong>“으로 이해했다.</p>\n<p>따라서 REST라는 단어 자체를 ”<strong>이해하기 용이한 형태로 상태가 표현된 정보 간의 교환</strong>“으로 직역해서 이해했다. (오역이라면 지적 부탁드립니다.)</p>\n<h1>REST의 구성 요소</h1>\n<p>REST에는 3가지의 구성 요소가 존재한다. 이 3가지의 구성 요소가 REST API 디자인의 근간을 이룬다.</p>\n<blockquote>\n<ol>\n<li><strong>자원</strong> (Resource) : URI</li>\n<li><strong>행위</strong> (Verb) : HTTP Method</li>\n<li><strong>표현</strong> (Representations)</li>\n</ol>\n</blockquote>\n<h2>1. 자원 (Resource) : URI</h2>\n<p><strong>URI(Uniform Resource Identifier)</strong> 는 <strong>정보의 자원을 표현</strong>해야 한다.</p>\n<p>URI는 <strong>단순하고 직관적인 구조</strong>이어야 하며, 모든 자원은 각 자원을 구별하기 위한 <strong>Unique ID</strong>를 가진다.</p>\n<p>URI의 설계 디자인에 관한 자세한 내용은 후술한다.</p>\n<h2>2. 행위 (Verb) : HTTP Method</h2>\n<p><strong>자원에 대한 행위</strong>는 HTTP 프로토콜의 Method(<strong>GET, POST, PUT, DELETE</strong>)으로 표현한다.</p>\n<p>HTTP 메소드에 관한 자세한 내용은 후술한다.</p>\n<h2>3. 표현 (Representations)</h2>\n<p>클라이언트가 자원에 대해 요청을 하면 <strong>서버는 이에 적절한 표현 (Representation), 즉 응답 (Response)</strong> 을 보내야 한다.\n응답 데이터는 JSON, XML, HTML 등 여러 형태로 나타낼 수 있다. 최근에는 Key, Value를 가진 형태의 <strong>JSON</strong>을 통해 응답 데이터를 전달받는 것이 일반적이다.</p>\n<p>또한, <strong>요청에 대한 응답의 Status Code를 적절하게 전달</strong>해주어야 한다.</p>\n<h1>REST 아키텍처의 6원칙</h1>\n<p>이론상 REST에는 6가지의 아키텍처 원칙이 있다.</p>\n<blockquote>\n<ol>\n<li><strong>Uniform Interface</strong> (균일한 인터페이스)</li>\n<li><strong>Client-Server 구조</strong></li>\n<li><strong>Stateless</strong> (무상태성)</li>\n<li><strong>Cacheable</strong> (캐싱 처리 가능)</li>\n<li><strong>Layered System</strong> (계층형 시스템 구조)</li>\n<li><strong>Code-On-Demand</strong> (optional)</li>\n</ol>\n</blockquote>\n<h2>1. Uniform Interface (균일한 인터페이스)</h2>\n<p>Uniform Interface는 요청이 어디에서 오는지와 무관하게, <strong>동일한 리소스에 대한 모든 API 요청은 동일하게 보여야 한다</strong>는 것을 말한다.\n<strong>Uniform Interface의 4가지 제약 조건</strong>은 다음과 같다.</p>\n<h3>1-1. Resource identification in requests</h3>\n<p>REST의 3요소 중 하나인 Resource (자원)는 <strong>요청을 통해서 식별</strong>된다. REST API에서는 자원이 <strong>URI</strong>로 표현되기 때문에, 각각의 <strong>자원은 URI을 통해 식별</strong>된다.</p>\n<h3>1-2. Resource manipulation through representations</h3>\n<p>Representation (표현)을 통해 자원을 조작한다. 클라이언트가 어떤 자원에 대해 표현과 메타 데이터를 충분히 갖추고 있다면, 클라이언트는 해당 자원의 상태를 수정하거나 삭제할 수 있다.</p>\n<h3>1-3. Self-descriptive messages</h3>\n<p>REST의 가장 중요한 원칙 중 하나로, 각 요청의 메시지 (즉 URI) 모습 자체만으로 어떤 동작이나 정보를 제공하는지 스스로를 설명할 수 있어야 한다.</p>\n<h3>1-4. Hypermedia as the engine of application state (HATEOAS)</h3>\n<p>하이퍼 미디어(링크)를 <strong>애플리케이션의 상태를 전이</strong>하기 위한 메커니즘으로 사용해야한다. 즉, 클라이언트가 서버에 어떠한 요청을 할 때, <strong>해당 요청과 관련된 (필요한) URI를 응답에 포함시켜 반환</strong>해야한다. 따라서 클라이언트는 최소한의 API URI만 알면, 반환되는 자원과 관련하여 처리 가능한 API URI를 모두 찾아내서 사용할 수 있다. 이러한 응답 형식을 HAL(Hypertext Application Language)라고 한다.</p>\n<h2>2. Client-Server 구조</h2>\n<blockquote>\n<ul>\n<li><strong>Client</strong> : 자원을 Request하는 쪽. 유저 인증이나 context(세션, 쿠키, 로그인 정보) 등을 관리</li>\n<li><strong>Server</strong> : 자원을 Response하는 쪽. API를 제공하고 비즈니스 로직 처리를 담당</li>\n</ul>\n</blockquote>\n<p>서버와 클라이언트는 각각의 역할에 따라 확실히 구분되어 있기 때문에 독립적이며 서로 간에 의존성이 적어야 한다.</p>\n<h2>3. Stateless (무상태성)</h2>\n<p>HTTP 프로토콜은 Stateless Protocol이므로 REST를 준수하는 REST API 역시 <strong>무상태성</strong>을 갖는다.</p>\n<p>다시 말해 <strong>클라이언트 요청과 관련된 정보를 별도로 저장하고 관리하지 않는다</strong>. 즉, 세션이나 쿠키와 같은 상태 관리를 별도로\u001d 행하지 않기 때문에 서버는 <strong>클라이언트를 식별하지 못한다</strong>. 상태를 기억하지 않는다. 또한, 이전 요청이 다음 요청의 처리에 영향을 주어서는 안된다.</p>\n<p>따라서 API 서버는 들어오는 요청만을 단순히 처리만 하면 된다. 때문에 서버에서 불필요한 상태 관리를 하지 않음으로써 <strong>구현이 단순</strong>해진다.</p>\n<h2>4. Cacheable (캐싱 처리 가능)</h2>\n<p>HTTP가 가진 가장 강력한 특징 중 하나인 캐싱을 적용할 수 있다. 오래된 데이터나 부적절한 데이터를 제공하지 못하도록 클라이언트 또는 서버 측에서 캐싱 처리를 적용할 수 있다. 캐싱을 적용하면, 응답시간이 빨라지고 REST Server 트랜잭션이 발생하지 않기 때문에 <strong>전체 응답시간, 성능, 서버의 자원 이용률을 향상</strong>시킬 수 있다.</p>\n<h2>5. Layered System (계층형 시스템 구조)</h2>\n<p>서버는 <strong>다중 계층</strong>으로 구성될 수 있다. 서버는 <strong>부하 분산</strong>을 위해 로드 밸런싱을 추가할 수도 있으며 앞단에 보안, 로드 밸런싱, 암호화, 사용자 인증 등을 추가하여 구조상의 유연성을 줄 수 있다. 또한 PROXY, 게이트웨이 같은 네트워크 기반의 중간 매체를 사용할 수 있다.</p>\n<h2>6. Code-On-Demand (optional)</h2>\n<p>옵션 사항이다. (반드시 충족할 필요는 없는 사항)</p>\n<p>서버는 <strong>클라이언트에게 Java applets나 JavaScript 코드를 전송</strong>하여 <strong>클라이언트 기능을 확장</strong>할 수 있게 한다. 서버로부터 전송된 코드는 사전 구현에 필요한 기능의 수를 줄임으로써 클라이언트를 단순화한다. 서버는 코드의 형태로 클라이언트에 제공되는 기능의 일부를 제공할 수 있으며 클라이언트는 코드를 실행하기만 하면 된다.</p>\n<h1>RESTful한 API 설계하기</h1>\n<p>와, 지금까지 정말 딱딱한 개념들을 살펴본 것 같다👀</p>\n<p>위에 소개된 개념들을 모두 완전히 이해하지는 못하더라도, REST API를 적절하게 설계하기 위해서는 한 번쯤은 읽어보는 것을 추천한다.</p>\n<p>결국, REST라는 개념의 포인트는</p>\n<blockquote>\n<ol>\n<li><strong>URI는 정보의 자원을 표현</strong>하되, URI의 형태 자체만으로 <strong>어떤 동작이나 정보를 제공하는지 스스로를 표현</strong>할 수 있어야 함</li>\n<li>자원에 대한 <strong>행위는 HTTP Method</strong>(GET, POST, PUT, DELETE)로 표현함</li>\n<li>응답 데이터는 상황에 따라 포맷이 다르지만 <strong>JSON</strong>이 보편적. Status Code도 반환 필수</li>\n</ol>\n</blockquote>\n<p>를 관통하게 되는 것 같다.</p>\n<p>REST 요소와 원칙, 개념을 의식하며 REST API를 설계해보자.</p>\n<h2>URI는 정보의 자원을 표현해야 한다</h2>\n<p>다음은 자원을 구체적으로 URI로 표현하기 위한 규칙이다.</p>\n<h3>1. URI는 동사보다 명사를, 대문자는 사용하지 않으며 소문자만 사용한다</h3>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/dc61d879f7cffd2f3d9911c1d3f13b58/bc563/resource.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 53.79746835443038%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAAAsTAAALEwEAmpwYAAABhElEQVQoz42S227bMBBE/f9/lb4ngAvUCGK7aSvqQlGyRUoyb5JOIdmx09YpssBwF4vBcJbcFZeYpol78b7/Eed9rGbSG3Gz2fDl4YGnx0fW6zUhhKvQPdy7ZMUbAXDekwjBy3ZL23WMl/5Hvu6JruYjOIdrW0bniNZijYEYOWmNnfsxErUmNA2DtYTjkcG5m3tuwotgm2XooqBTiibPqZJkqbWUNGmKq2v6/Z5uu8WmKf1uhxWCaRz/cbuMbJXi5Bw+BnpraYxeaj8MWKMJWi8uR++JfU9wFt8ZhuCJY2QYh+u7Lg6l/El5LKiMoqhzMiVQjaRua2SVog4Zz+Uz+2rH6+GVr9majfyGaATfqx3GmT9HFvIHsilRuiIpBb9kQnGQ1N2RrBLUWiLbglxnpI1AtSVZI5Amp3Mtxmp6390+pc9TjMrp6pL+qOgPZ7SHEpMl+HnsKeKjO2PwS3bRYYNdMPeuglMcmHxgCuGcL/Vwmt+qYxxGPhPLyJ/Z/v8t99+L/hsmC1brHIBm5gAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Resource\"\n        title=\"Resource\"\n        src=\"/static/dc61d879f7cffd2f3d9911c1d3f13b58/984b6/resource.png\"\n        srcset=\"/static/dc61d879f7cffd2f3d9911c1d3f13b58/4d6f2/resource.png 158w,\n/static/dc61d879f7cffd2f3d9911c1d3f13b58/3c1ae/resource.png 315w,\n/static/dc61d879f7cffd2f3d9911c1d3f13b58/984b6/resource.png 630w,\n/static/dc61d879f7cffd2f3d9911c1d3f13b58/bc563/resource.png 736w\"\n        sizes=\"(max-width: 630px) 100vw, 630px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p>자원을 테이블로 표현한다면 위와 같은 형태가 된다.\n자원은 <code class=\"language-text\">Collection</code>과 <code class=\"language-text\">Element</code>로 나누어 표현할 수 있다.</p>\n<blockquote>\n<ul>\n<li><strong>Collection</strong>: Element의 집합. <strong>복수형</strong> 명사 사용</li>\n<li><strong>Element</strong>: 한 건 한 건의 개별 데이터. 기본적으로 id로 식별하지만, 문자로 식별할 때는 <strong>단수형</strong> 명사 사용</li>\n</ul>\n</blockquote>\n<p>URI에는 동사(행위)를 포함하지 않는다. 행위를 나타내기 위해서는 후술할 HTTP 메소드들을 사용한다.\n따라서, 자원은 <strong>명사로 표현</strong>하며 대문자가 아닌 <strong>소문자만 사용</strong>한다. 대소문자에 따라 다른 자원으로 인식하게 되기 때문이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token comment\"># Bad Example</span>\n/getPosts/2</code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token comment\"># Good Example</span>\n/posts/2</code></pre></div>\n<p>단, 컨트롤 자원을 의미하는 경우에는 예외적으로 동사를 허용한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token comment\"># Bad Example</span>\n/posts/duplicating</code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token comment\"># Good Example</span>\n/posts/duplicate</code></pre></div>\n<h3>2. 자원에 대한 행위는 HTTP Method로 표현한다</h3>\n<p>URI에는 동사(행위)를 포함하지 않는다. 예를 들어 아래와 같은 URI가 존재한다고 하자.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token comment\"># Bad Example</span>\n/create-post/2\n/get-post/2\n/update-post/2\n/delete-post/2</code></pre></div>\n<p>한눈에 보기에도 직관적이지 않고 장황하다. 이것을 지양하기 위한 REST 규칙 중 하나로 URI는 동사가 아닌 명사들로만 이루어져야 한다는 것이 있다.</p>\n<p>그 대신, <strong>자원에 대한 행위는 <a href=\"https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods\">HTTP 메소드</a>로 표현</strong>한다.</p>\n<p>클라이언트가 서버에 REST API로 요청을 보낼 때는 <strong>HTTP라는 프로토콜에 따라 요청을 전송</strong>한다.</p>\n<p>HTTP 통신 환경에는 여러 가지 요청 메소드들이 존재하는데, 이 메소드들은 엄밀히 특정 용도에 제한되어 있지는 않다. 아래와 같이 POST라는 메소드만으로 데이터를 읽고 쓰고 수정하고 삭제까지 가능하다.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token comment\"># Bad Example</span>\nPOST /post/2\nPOST /post/2\nPOST /post/2\nPOST /post/2</code></pre></div>\n<p>모두 똑같이 생겼지만, 사실은 모두 읽고 쓰고 지우고 갱신하기 위한 API이다. 이런 방식으로 URI를 설계해도 문제 없이 동작은 하겠지만, <strong>POST라는 메소드만으로는 정확히 이 API가 어떤 처리를 행하는지 파악하기가 힘들다</strong>. 또한, 주로 팀으로 진행되는 개발 환경에서는 <strong>원활한 협업을 위해 팀 구성원이 모두 이해할 수 있는 형태로 프로그래밍을 하는 것이 중요</strong>하다.</p>\n<p>따라서, <strong>요청을 보내는 URI만으로도 누구든지 각 요청의 의도를 쉽게 파악할 수 있도록 설계</strong>해야한다. RESTful하게 API를 만들기 위해서는 <strong>HTTP 메소드를 목적에 따라 구분해서 사용</strong>해야 한다. HTTP 메소드를 알맞은 역할대로 나눈 것이 <strong>CRUD</strong>이다.</p>\n<table>\n<thead>\n<tr>\n<th>Method</th>\n<th>Action</th>\n<th>역할</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>POST</td>\n<td>Create</td>\n<td>새로운 자원을 추가, 생성</td>\n</tr>\n<tr>\n<td>GET</td>\n<td>Read</td>\n<td>자원을 조회, 가져옴</td>\n</tr>\n<tr>\n<td>PUT</td>\n<td>Update</td>\n<td>해당 자원의 전체를 수정</td>\n</tr>\n<tr>\n<td>PATCH</td>\n<td>Update</td>\n<td>해당 자원의 일부만 수정</td>\n</tr>\n<tr>\n<td>DELETE</td>\n<td>Delete</td>\n<td>해당 자원을 삭제</td>\n</tr>\n</tbody>\n</table>\n<p>위의 HTTP 메소드의 역할에 따라 다시 URI를 구성해보자.</p>\n<h4>POST</h4>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token comment\"># 새로운 포스팅 생성, 추가</span>\nPOST /posts/4</code></pre></div>\n<h4>GET</h4>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token comment\"># 모든 포스팅 조회</span>\nGET /posts\n\n<span class=\"token comment\"># 1번 포스팅 조회</span>\nGET /posts/1</code></pre></div>\n<h4>PUT, PATCH</h4>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token comment\"># PUT: 모든 포스팅 정보 수정 (작성자, 날짜, 제목, ID 등 포스팅 관련 모든 정보를 수정할 때)</span>\nPUT /posts/1\n\n<span class=\"token comment\"># PATCH: 포스팅의 일부 정보 수정 (날짜만 수정할 때)</span>\nPATCH /posts/1</code></pre></div>\n<h4>DELETE</h4>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token comment\"># 2번 포스팅 삭제</span>\nDELETE /posts/2</code></pre></div>\n<h3>3. 슬래시(/)는 계층 관계를 구분하기 위해 사용</h3>\n<p>블로그 포스팅 관련 API의 URI을 구성한다고 하자. 위의 예시 일러스트에서 소개된 URI처럼 블로그의 포스팅 중 2번 포스팅의 글을 조회하는 경우에는 다음과 같이 표현한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">GET /posts/2</code></pre></div>\n<p><strong><code class=\"language-text\">/</code>로 계층 관계를 구분</strong>해서 posts라는 큰 범주 내에 존재하는 2번 포스팅이라는 것을 표현하고 있다.</p>\n<h3>4. URI 마지막 문자로 슬래시(/)를 포함하지 않는다</h3>\n<p>바로 위 2번에서 <code class=\"language-text\">/</code>는 계층 관계를 구분하기 위해 사용하는 것이기 때문에, 마지막에는 (더이상 계층이 없기 때문에) 슬래시를 사용하지 않는다.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token comment\"># Bad Example</span>\nPOST /posts/2/</code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token comment\"># Good Example</span>\nPOST /posts/2</code></pre></div>\n<h3>5. 언더 바(_) 대신 하이픈(-) 사용</h3>\n<p>언더바 (_)는 사용하지 않는다. 대신 <strong>하이픈 (-)을 사용</strong>한다.</p>\n<p>다만 가급적 하이픈의 사용도 최소화하며, <strong>URI 가독성을 높이기 위해 단어의 결합이 불가피한 경우</strong>에 사용한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token comment\"># Bad Example</span>\nGET /posts/what_is_a_rest_api</code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token comment\"># Good Example</span>\nGET /posts/what-is-a-rest-api</code></pre></div>\n<h3>6. URI에는 파일 확장자를 포함시키지 않는다</h3>\n<p>REST API에서는 메시지 바디 내용의 포맷을 나타내기 위한 <strong>파일 확장자를 URI 안에 포함시키지 않는다</strong>. 그 대신 Accept header를 사용해 Context의 타입을 전달한다.</p>\n<p>예를 들어 <code class=\"language-text\">Hello,World</code>라는 내용을 가진 파일이 있다고 가정하자.</p>\n<p>이 파일을 <code class=\"language-text\">txt</code>와 <code class=\"language-text\">csv</code>로 모두 제공하려면</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token comment\"># Bad Example</span>\n/posts/2/hello.txt\n/posts/2/hello.csv</code></pre></div>\n<p>두 가지의 API를 준비해야하며, 서버에는 <code class=\"language-text\">hello.txt</code>, <code class=\"language-text\">hello.csv</code> 두 개의 파일로 존재할 것이다. 위의 두 URI은 분명히 다른 자원을 식별하는 URI이지만, <strong>실제로는 하나의 자원</strong>을 가리키고 있다. 이것은 <strong>비효율적</strong>인 방법이다. <strong>자원이 하나라면 URI도 하나</strong>여야 한다.</p>\n<p>따라서, REST API에서는 URI에 파일 확장자를 포함시키지 않고 해당 요청이 왔을 때 Accept header를 적절히 파싱해서 클라이언트가 요청한대로 응답해주면 된다.</p>\n<p>RESTful하게 API를 설계하면 아래와 같다.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token comment\"># Good Example</span>\nGET /posts/2/hello HTTP/1.1\nHost: example.com\nAccept: text/plain\n\nGET /posts/2/hello HTTP/1.1\nHost: example.com\nAccept: text/csv</code></pre></div>\n<h3>7. 필터를 위해 쿼리 파라미터를 사용한다</h3>\n<p>자원에 대한 <strong>세부적인 정렬, 페이징, 필터링</strong> 등은 신규 API를 생성하지 않고 <strong>쿼리 파라미터를 사용</strong>한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token comment\">// 장르가 2(로맨스)이고 status가 1(상영중)인 영화 중, 3번 index부터 5개의 영화를 조회</span>\n<span class=\"token constant\">GET</span> <span class=\"token operator\">/</span>movies<span class=\"token operator\">?</span>genres<span class=\"token operator\">=</span><span class=\"token number\">2</span><span class=\"token operator\">&amp;</span>offset<span class=\"token operator\">=</span><span class=\"token number\">1</span><span class=\"token operator\">&amp;</span>limit<span class=\"token operator\">=</span><span class=\"token number\">5</span><span class=\"token operator\">&amp;</span>status<span class=\"token operator\">=</span><span class=\"token number\">1</span></code></pre></div>\n<h3>8. 리소스 간에는 연관 관계가 있는 경우</h3>\n<p>REST 리소스 간에는 연관 관계가 있을 수 있다. 예를 들어 유저가 로그인 중인 디바이스 목록이나 유저가 좋아하는 영화 등과 같은 관계를 말한다. <code class=\"language-text\">유저-디바이스</code> 또는 <code class=\"language-text\">유저-영화</code> 등과 같이 각각의 자원 간의 관계를 표현해야 한다.</p>\n<p>이런 경우 REST API에서는 <code class=\"language-text\">/자원명/자원 ID/관계가 있는 자원명</code>과 같은 표현 방법으로 사용한다.</p>\n<p>예를 들어, 유저가 로그인 중인 디바이스 목록을 표현해보면 아래와 같다.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">GET /users/<span class=\"token punctuation\">{</span>userid<span class=\"token punctuation\">}</span>/devices\nGET /users/hayoung/devices</code></pre></div>\n<p>또한, 유저가 좋아하는 영화 목록을 표현해보면 아래와 같다.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token comment\"># 일반적으로 소유 ‘has’의 관계를 표현</span>\nGET /users/<span class=\"token punctuation\">{</span>userid<span class=\"token punctuation\">}</span>/likes/movies\nGET /users/hayoung/likes/movies</code></pre></div>\n<h2>HTTP 응답 상태 코드</h2>\n<p>마지막으로 REST API는 자원에 대한 적절한 응답을 반환해주는 것까지 포함되어야 한다. 정확한 응답의 상태 코드만으로 클라이언트는 응답에 대한 상태를 빠르게 파악할 수 있으며, 요청이 정상적으로 처리가 되었는지 파악할 수 있기 때문이다.</p>\n<p>상태 코드는 5개의 그룹으로 나누어진다.</p>\n<blockquote>\n<ul>\n<li><strong>1xx</strong> (정보) : 요청을 받았으며 프로세스를 계속 진행할 것임</li>\n<li><strong>2xx</strong> (성공) : 요청을 정상적으로 받았으며 응답 성공</li>\n<li><strong>3xx</strong> (리다이렉션) : 클라이언트는 요청 완료하기 위해 추가적인 행동을 취해야 함</li>\n<li><strong>4xx</strong> (클라이언트 오류) : 클라이언트의 부적절한 요청. 요청의 문법이 잘못되었거나 요청을 처리할 수 없음</li>\n<li><strong>5xx</strong> (서버 오류) : 서버 측의 오류 발생</li>\n</ul>\n</blockquote>\n<p>세부적인 상태 코드는 <a href=\"https://www.whatap.io/ko/blog/40/\">이 블로그</a>가 자세하니 참고.</p>\n<h1>마치며</h1>\n<p>결국 REST API란, HTTP 요청을 보낼 때 위의 규칙들로 구성된 URI에 적절한 HTTP 메소드를 사용할 것인지에 대해 개발자들 사이에서 널리 지켜지고 있는 약속이다. REST 원칙을 기반으로 암묵적으로 통용되고 있는 형식인 것이다. 따라서 <strong>명확한 표준이 없기 때문에</strong>, REST에 대한 이해를 바탕으로 현재 우리 조직의 <strong>스펙과 시스템에 맞춰서 표준화된 가이드라인을 가지고 그것을 구성원 모두가 준수하도록 노력</strong>해야한다.</p>\n<h1>References</h1>\n<ul>\n<li><a href=\"https://gmlwjd9405.github.io/2018/09/21/rest-and-restful.html\">https://gmlwjd9405.github.io/2018/09/21/rest-and-restful.html</a></li>\n<li><a href=\"https://meetup.toast.com/posts/92\">https://meetup.toast.com/posts/92</a></li>\n<li><a href=\"https://wallees.wordpress.com/2018/04/19/rest-api-hateoas/\">https://wallees.wordpress.com/2018/04/19/rest-api-hateoas/</a></li>\n<li><a href=\"https://en.wikipedia.org/wiki/Representational_state_transfer\">https://en.wikipedia.org/wiki/Representational_state_transfer</a></li>\n<li><a href=\"https://www.youtube.com/watch?v=PmY3dWcCxXI\">https://www.youtube.com/watch?v=PmY3dWcCxXI</a></li>\n<li><a href=\"https://jaweb.tistory.com/entry/REST-RestFul%EC%9D%B4%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80\">https://jaweb.tistory.com/entry/REST-RestFul%EC%9D%B4%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80</a></li>\n<li><a href=\"https://developer.mozilla.org/ko/docs/Web/HTTP/Status\">https://developer.mozilla.org/ko/docs/Web/HTTP/Status</a></li>\n</ul>","timeToRead":11,"frontmatter":{"title":"REST API란?","date":"October 29, 2021","description":"REST 원칙과 그 원칙에 따라 구현된 API인 REST API를 설계하는 방법에 대해 알아보자."}},"previous":{"fields":{"slug":"/js-event-delegation/"},"frontmatter":{"title":"JavaScript의 이벤트 전파 (이벤트 캡쳐링, 이벤트 버블링) 그리고 이벤트 위임"}},"next":null},"pageContext":{"id":"ac045ddb-22a4-59c5-a33f-faed877d4795","previousPostId":"54a46ba1-8e55-56be-9da7-94e75ba8eeee","nextPostId":null}},
    "staticQueryHashes": ["230163734","2841359383"]}